# 强缓存与协商缓存
浏览器缓存是浏览器在本地磁盘对用户最近请求过的资源进行储存，当访问者在此访问同一资源时，浏览器就可以直接从本地磁盘加载资源，通过缓存的方式就可以减少与服务器的数据传输，减少服务器的负担，加快页面响应速度等。

## 分类
缓存分为两种：强缓存和协商缓存，根据响应的header内容来决定。

* 协商缓存相关字段有Last-Modified/If-Modified-Since，Etag/If-None-Match


 /    获取资源形式     /   状态码      /   是否发送请求到服务器 
     ---- / ---- / ----
强缓存  /  从缓存取  / 200（from cache）  /  否，直接从缓存取
协商缓存  /  从缓存取  /  304（not modified）  /  是，通过服务器来告知缓存是否可用

### 强缓存
强缓存是通过`Expires`与`Cache-Control`来控制缓存在本地的有效期。如果`cache-control`与`expires`同时存在的话，`cache-control`的优先级高于`expires`。

#### Expires
描述的是一个绝对时间，由服务器返回。`Expires`受限于本地时间，如果修改了本地时间，可能会造成缓存失效.对于资源的请求，如果在`Expires`之内，则浏览器会直接读取缓存，不再请求服务器。

#### Cache-Control
`Cache-Control`出现于`HTTP 1.1`，优先级高于`Expires`，表示的是相对时间，请求头和响应头都支持这个属性，通过它提供的不同的值来定义缓存策略。

```
Cache-Control: max-age=300
```

* `Cache-Control: no-store`: 缓存中不得存储任何关于客户端请求和服务端响应的内容，每次由客户端发起的请求都会下载完整的响应内容。
* `Cache-Control: no-cache`: 缓存中会存储服务端响应的内容，只是在与服务端进行新鲜度再验证之前，该缓存不能够提供给浏览器使用。简单来说，就是浏览器会将服务端响应的资源进行缓存，但是在每次请求时，缓存都要向服务端评估缓存响应的有效性，协商缓存是否可用，根据响应是`304`还是`200`判断是使用本地缓存资源还是使用服务器响应的资源。
* `Cache-Control: public || private`: `public`表示该响应可以被任何中间人比如中间代理、`CDN`等缓存。默认响应为`private`，`private`表示该响应是专用的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。
* `Cache-Control: max-age=31536000`: 响应为最大的过期时间，其指令是`max-age=<seconds>`，表示资源能够被缓存即保持新鲜的最大时间，`max-age`是距离请求发起的时间的秒数。
* `Cache-Control: must-revalidate`: 当使用了`must-revalidate`指令，那就意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用。在正常情况下是没有必要使用这个指令的，因为在强缓存过期的情况下会进行协商缓存，但是`HTTP`规范是允许客户端在某些特殊情况下直接使用过期缓存的，比如校验请求发送失败的时候，还比如有配置一些特殊指令`stale-while-revalidate`、`stale-if-error`等的时候，`must-revalidate`指令就是让缓存在过期后的任何情况下都必须重新验证。

### 协商缓存
当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的`HTTP`状态为`304 (Not Modified)`，该请求不携带实体数据，若未命中，则返回`200`并携带资源实体数据。协商缓存是利用的是`Last-Modified，If-Modified-Since`和`ETag、If-None-Match`这两对`Header`来管理的。

#### Last-Modified If-Modified-Since
`Last-Modified，If-Modified-Since`是`HTTP 1.0`引入的，`Last-Modified`表示本地文件最后修改日期，浏览器会在请求头加上`If-Modified-Since`即上次响应的`Last-Modified`的值，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，但是如果在本地打开缓存文件，就会造成`Last-Modified`被修改，所以在`HTTP 1.1`出现了`ETag`。

#### ETag If-None-Match
`Etag`就像一个指纹，资源变化都会导致`ETag`变化，跟最后修改时间没有关系，`ETag`可以保证每一个资源是唯一的，`If-None-Match`的请求头字段会将上次返回的`Etag`发送给服务器，询问该资源的`Etag`是否有更新，有变动就会发送新的资源回来。`ETag`的优先级比`Last-Modified`更高，具体使用`ETag`主要出于下面几种情况考虑：
* 一些文件也许会周期性的更改，但是他的内容并不改变，比如仅仅改变的修改时间，这个时候我们并不希望客户端认为这个文件被修改了，而重新`GET`。
* 某些文件修改非常频繁，比如在秒以下的时间内进行修改，例如`1s`内修改了`N`次，`If-Modified-Since`能检查到的粒度是秒级的，这种修改无法判断。
* 某些服务器不能精确的得到文件的最后修改时间。