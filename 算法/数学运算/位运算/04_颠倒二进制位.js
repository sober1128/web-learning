/*
  (1)循环32次，r每次左移一位，n每次右移一位，n & 1取得最右位的数，放入r
      若r已经31位（如1011111111111111111110111111110），继续左移1位，最左侧的1移到符号位，含义变成-
  (2) >>>0，利用>>>无符号右移时，会将符号位重新看作数，不真正位移
      第32位的1不再代表-，-消失。代表数，多了2的32次方
      >>>0的结果 = 原来负数 + 2的32次方，负数变回无符号整数
*/

/*
  关键点解析
    1.可以用任何数字和 1 进行位运算的结果都取决于该数字最后一位的特性简化操作和提高性能
          eg :
          n & 1 === 1, 说明 n 的最后一位是 1
          n & 1 === 0, 说明 n 的最后一位是 0
    2.对于 JS，ES 规范在之前很多版本都是没有无符号整形的， 转化为无符号，可以用一个 n >>> 0;

*/
var reverseBits = function (n) {
  let res = 0;
  for(let i = 0; i < 32; i++) {
    res = (res << 1) + (n & 1);   // n & 1 -- 得到末尾的值
    n = n >> 1;
  }
  return res >>> 0;  // 无符号右移 负数的二进制表示当成正数的二进制表示来处理 （处理与）
}